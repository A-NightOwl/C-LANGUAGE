```C
int main()
{
    int arr1[5] = { 1,2,3,4,5 };
	int arr2[5] = { 2,3,4,5,6 };
	int arr3[5] = { 3,4,5,6,7 };
 
	int* arr[3] = {arr1, arr2, arr3};
    //arr也是一个指针数组，利用指针数组实现二维数组
    int i = 0;
	int j = 0;
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 5; j++)
		{
			printf("%d ", arr[i][j]);	// arr[i][j] 《==》 *(arr[i] + j) 
		}
		printf("\n");
	}
    return ;
}

```


在C语言中，arr[i][j]  这种表达式实际上涉及到数组和指针的解引用操作，但这种操作是**隐式**的。让我们逐步分析为什么 arr[i][j] 不需要显式解引用。

**数组和指针的关系**
<br>在C语言中，数组名可以被用作指向数组第一个元素的指针。这意味着当你有一个数组 arr，arr 实际上是一个指针，指向 arr 的第一个元素。

**指针数组**
<br>在代码中，arr 是一个指针数组，每个元素都是一个指向 int 类型的指针。因此，arr[i] 实际上是一个指针，指向 arr1、arr2 或 arr3 的第一个元素。

**访问元素**
<br>当你访问 arr[i][j] 时，这里发生了两步操作：

1. 访问指针数组的元素：arr[i] 访问指针数组中的第 i 个元素，这是一个指针。
2. 访问指针指向的数组的元素：arr[i][j] 实际上是 *(arr[i] + j) 的简写形式。

**解释 arr[i][j]：**
- arr[i] 是一个指针，指向 arr1、arr2 或 arr3 的第一个元素。
- arr[i] + j 是指针算术，它将指针向前移动 j 个 int 的大小，指向第 j+1 个元素（因为指针是从0开始索引的）。
- arr[i][j] 实际上是 *(arr[i] + j) 的简写。这里的 * 是解引用操作，但它是隐式的，因为当你通过数组索引访问元素时，C语言会自动解引用指针。

**为什么不需要显式解引用**
<br>在C语言中，当你通过数组索引访问元素时，编译器会自动处理解引用操作。这是C语言的一个特性，允许你使用 arr[i][j] 这样的语法来简化代码。实际上，arr[i][j] 被编译器解释为 *(arr[i] + j)，其中 * 是隐式添加的。

这种隐式解引用是C语言设计的一部分，它使得数组访问更加直观和方便。因此，你不需要显式地写出解引用操作符 *，除非你需要明确地进行指针操作或者强调解引用的意图。

总结来说，arr[i][j] 不需要显式解引用是因为C语言的语法规则自动处理了这一步骤，使得代码更加简洁和易于理解。